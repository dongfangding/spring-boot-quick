######################################水平分表配置############################################################

spring:
  main:
    allow-bean-definition-overriding: true

  # 经测试filter需要配置再datasource.druid下，而每个连接的信息还是得配置在sharding-sphere下的datasource每个自己的
  datasource:
    druid:
      filter:
        stat:
          enabled: true
          log-slow-sql: true
          slow-sql-millis: 3000
        wall:
          enabled: true # 开启WallFilter
          db-type: mysql
      ## 开启内置监控界面 访问路径: /context-path/druid/index.html
      stat-view-servlet:
        enabled: true
        url-pattern: /druid/*
        reset-enable: true
        login-username: admin
        login-password: 123456

  shardingsphere:
    datasource:
      names: master,slave0,slave1
      # 配置数据源
      master:
        type: com.alibaba.druid.pool.DruidDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://${mysql.host}:${mysql.port}/${mysql.db}?useUnicode=true&characterEncoding=UTF8&useSSL=false&serverTimezone=GMT%2B8&zeroDateTimeBehavior=convertToNull&allowMultiQueries=true&autoReconnect=true&failOverReadOnly=false&maxReconnects=10&tinyInt1isBit=false
        username: ${mysql.username}
        password: ${mysql.password}
        initial-size: 5
        max-active: 20
        min-idle: 10
        max-wait: 60000
        time-between-eviction-runs-millis: 60000
        min-evictable-idle-time-millis: 300000
        ## 回收连接相关
        validation-query: SELECT 1
        test-while-idle: true
        test-on-borrow: false
        test-on-return: false
        poolPreparedStatements: true
        max-open-prepared-statements: 20
        async-init: true
      # 配置数据源
      slave0:
        type: com.alibaba.druid.pool.DruidDataSource
        slave0.driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://localhost:3307/${mysql.db}?useUnicode=true&characterEncoding=UTF8&useSSL=false&serverTimezone=GMT%2B8&zeroDateTimeBehavior=convertToNull&allowMultiQueries=true&autoReconnect=true&failOverReadOnly=false&maxReconnects=10&tinyInt1isBit=false
        username: root
        password: 123456
        initial-size: 5
        max-active: 20
        min-idle: 10
        max-wait: 60000
        time-between-eviction-runs-millis: 60000
        min-evictable-idle-time-millis: 300000
        ## 回收连接相关
        validation-query: SELECT 1
        test-while-idle: true
        test-on-borrow: false
        test-on-return: false
        poolPreparedStatements: true
        max-open-prepared-statements: 20
        async-init: true
      # 配置数据源
      slave1:
        type: com.alibaba.druid.pool.DruidDataSource
        slave0.driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://localhost:3308/${mysql.db}?useUnicode=true&characterEncoding=UTF8&useSSL=false&serverTimezone=GMT%2B8&zeroDateTimeBehavior=convertToNull&allowMultiQueries=true&autoReconnect=true&failOverReadOnly=false&maxReconnects=10&tinyInt1isBit=false
        username: root
        password: 123456
        initial-size: 5
        max-active: 20
        min-idle: 10
        max-wait: 60000
        time-between-eviction-runs-millis: 60000
        min-evictable-idle-time-millis: 300000
        ## 回收连接相关
        validation-query: SELECT 1
        test-while-idle: true
        test-on-borrow: false
        test-on-return: false
        poolPreparedStatements: true
        max-open-prepared-statements: 20
        async-init: true

    # 配置主从规则
#    masterslave:
#      # 从库负载均衡算法
#      load-balance-algorithm-type: round_robin
#      # 读写分离数据源名称
#      name: ms
#      # 主库数据源名称， 从上面配置的数据源中选择
#      master-data-source-name: master
#      # 从库数据源名称列表， 从上面配置的数据源中选择
#      slave-data-source-names: slave0,slave1

    # 分支分片策略
    sharding:
      # 分表
      tables:
        # 逻辑表名， 即原表名比如有auth_user，现在分为实际的auth_user_1, auth_user_2, auth_user即为逻辑表名
        auth_user:
          # 配置数据表分布情况，哪个表在哪个库里
          actual-data-nodes: master.auth_user,master.auth_user_1
          table-strategy:
            # 指定当前表的分片策略
            inline:
              sharding-column: id
              # 配置分表策略， auth_user对id进行判断，如果为偶数则为auth_user,如果为奇数则为auth_user_1
              algorithm-expression: auth_user$->{id % 2 == 0 ?"":"_1"}

    props:
      #  显示sql具体信息
      sql.show: true
